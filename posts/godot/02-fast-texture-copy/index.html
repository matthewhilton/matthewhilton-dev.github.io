<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A tale as old as time - CPU bottlenecking
As described in my earlier post &ldquo;My plan to render 1 million trees&rdquo;, my game has a grid system of sprites; each one displays a small chunk of the world as rendered by the SubViewport. But because the viewport moves around, we can&rsquo;t simply just set each sprite to have a ViewportTexture as this would mean they all would display the same thing."><title>Fast texture copy from viewports
</title><link rel="shortcut icon" type=image/x-icon href=/><link rel=stylesheet href=/css/main.51652302d3a998bf7887aed5c2cf89141bbebdf45a2c8f87b0717a3cf4f51c4e53c694c328fb1de78c3a625a1c01f80745bf1f2f42c040647a245cbbb6c2d1d7.css integrity="sha512-UWUjAtOpmL94h67Vws+JFBu+vfRaLI+HsHF6PPT1HE5TxpTDKPsd54w6YlocAfgHRb8fL0LAQGR6JFy7tsLR1w=="><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@200..900&display=swap" rel=stylesheet><style>body{font-family:noto serif jp,serif;font-optical-sizing:auto}</style></head><body a=auto><main class=page-content aria-label=Content><div class=w><div class=post-meta><a href=/>..</a><p><time datetime="2024-09-05 00:00:00 +0000 UTC">2024-09-05</time></p></div><article><h1>Fast texture copy from viewports</h1><aside><nav id=TableOfContents><ul><li><a href=#a-tale-as-old-as-time---cpu-bottlenecking>A tale as old as time - CPU bottlenecking</a></li><li><a href=#the-fix>The fix</a><ul><li><a href=#how-this-works>How this works</a></li><li><a href=#a-note-about-terminology>A note about terminology</a></li><li><a href=#the-results>The results</a></li></ul></li></ul></nav></aside><h2 id=a-tale-as-old-as-time---cpu-bottlenecking>A tale as old as time - CPU bottlenecking</h2><p>As described in my earlier post <a href=../00-rendering-lots-of-trees>&ldquo;My plan to render 1 million trees&rdquo;</a>, my game has a grid system of sprites; each one displays a small chunk of the world as rendered by the SubViewport. But because the viewport moves around, we can&rsquo;t simply just set each sprite to have a <code>ViewportTexture</code> as this would mean they all would display the same thing.</p><p>I recently implemented an LOD system so that as you zoom in and out the game renders in more or less detail. I noticed as you zoomed in, the FPS really dropped as I increased the amount of detail to a level which I wanted.</p><p>What is interesting is this wasn&rsquo;t because of the number of trees being rendered, or really anything to do with the objects in the scene, but it was actually from two lines of code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript data-lang=gdscript><span style=display:flex><span><span style=color:#66d9ef>var</span> image <span style=color:#f92672>:=</span> <span style=color:#a6e22e>$Subviewport</span><span style=color:#f92672>.</span><span style=color:#a6e22e>get_texture</span>()<span style=color:#f92672>.</span><span style=color:#a6e22e>get_image</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> texture <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ImageTexture</span><span style=color:#f92672>.</span><span style=color:#a6e22e>create_from_image</span>(image)
</span></span></code></pre></div><p>These lines would grab what the viewport is currently seeing, and the create an image texture to set on the sprite.</p><p>Under the hood <code>get_texture().get_image()</code> appears to mainly be calling <code>RenderingDevice::texture_get_data</code>. Depending on the texture, this will call on the graphics driver (in my case, Vulkan) to give it a readable pointer to the textures data, where it will then read the data into memory and return an array of bytes which get put into an image resource.</p><p>Clearly, this is CPU bottlenecked, because it has to read from GPU to CPU to get the image, and then straight back to the GPU via an ImageTexture. You can see the processing times scale pretty badly:</p><table><thead><tr><th>Viewport size (square)</th><th>Processing time</th></tr></thead><tbody><tr><td>64</td><td>0.4ms</td></tr><tr><td>1024</td><td>33 ms</td></tr><tr><td>2048</td><td>89 ms</td></tr><tr><td>(Note, I this is not a scientific test, I only ran it a few times)</td><td></td></tr></tbody></table><p>For reference, 60fps is 1 frame every 16ms, so anything greater than this is less than ideal.</p><h2 id=the-fix>The fix</h2><p>After digging around a bit in the rendering code of Godot, I found this solution, which seems to remove the CPU from the operation entirely:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript data-lang=gdscript><span style=display:flex><span><span style=color:#66d9ef>var</span> rd <span style=color:#f92672>:=</span> <span style=color:#a6e22e>RenderingServer</span><span style=color:#f92672>.</span><span style=color:#a6e22e>get_rendering_device</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> imagesize <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Vector2i</span>(<span style=color:#ae81ff>1024</span>,<span style=color:#ae81ff>1024</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Get the texture RID and the texture format.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> in_texture <span style=color:#f92672>=</span> <span style=color:#a6e22e>RenderingServer</span><span style=color:#f92672>.</span><span style=color:#a6e22e>texture_get_rd_texture</span>(<span style=color:#a6e22e>$Subviewport</span><span style=color:#f92672>.</span><span style=color:#a6e22e>get_texture</span>()<span style=color:#f92672>.</span><span style=color:#a6e22e>get_rid</span>(), <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> in_tex_format <span style=color:#f92672>=</span> rd<span style=color:#f92672>.</span><span style=color:#a6e22e>texture_get_format</span>(in_tex)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Make a format to store the output based on the input texture.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># We need TEXTURE_USAGE_CAN_COPY_TO_BIT added so we can copy from the viewport to this one</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> out_tex_format <span style=color:#f92672>=</span> in_tex_format
</span></span><span style=display:flex><span>out_tex_format<span style=color:#f92672>.</span>usage_bits <span style=color:#f92672>=</span> out_tex_format<span style=color:#f92672>.</span>usage_bits <span style=color:#f92672>|</span> <span style=color:#a6e22e>RenderingDevice</span><span style=color:#f92672>.</span>TEXTURE_USAGE_CAN_COPY_TO_BIT
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Create the output texture.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> out_texture <span style=color:#f92672>=</span> rd<span style=color:#f92672>.</span><span style=color:#a6e22e>texture_create</span>(out_tex_format, <span style=color:#a6e22e>RDTextureView</span><span style=color:#f92672>.</span><span style=color:#a6e22e>new</span>(), [])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Copy from the viewport texture to the output texture.</span>
</span></span><span style=display:flex><span>rd<span style=color:#f92672>.</span><span style=color:#a6e22e>texture_copy</span>(in_texture, out_texture, <span style=color:#a6e22e>Vector3</span><span style=color:#f92672>.</span>ZERO, <span style=color:#a6e22e>Vector3</span><span style=color:#f92672>.</span>ZERO, <span style=color:#a6e22e>Vector3</span>(image_size<span style=color:#f92672>.</span>x, image_size<span style=color:#f92672>.</span>y, <span style=color:#ae81ff>0</span>), <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Create a texture that can be applied to a sprite.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> sprite_tex <span style=color:#f92672>=</span> Texture2DRD<span style=color:#f92672>.</span><span style=color:#a6e22e>new</span>()
</span></span><span style=display:flex><span>sprite_tex<span style=color:#f92672>.</span>texture_rd_rid <span style=color:#f92672>=</span> out_texture
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Use the texture....</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># After the resource is cleared, you may need to manually free the texture.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># It won&#39;t be cleared manually, because we created it directly ourselves.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Wait at least 1 frame after it is not used.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>await</span> <span style=color:#a6e22e>get_tree</span>()<span style=color:#f92672>.</span>process_frame
</span></span><span style=display:flex><span>rd<span style=color:#f92672>.</span><span style=color:#a6e22e>free_rid</span>(out_texture)
</span></span></code></pre></div><h3 id=how-this-works>How this works</h3><h3 id=a-note-about-terminology>A note about terminology</h3><p>There&rsquo;s a lot of obscure terminology, especially for someone who doesn&rsquo;t have much experience in 3D rendering pipelines and drivers (like myself circa 1 hour ago). I&rsquo;ll try to explain it simply, also, i&rsquo;ll probably make a few mistakes as well.</p><p>First lets make something clear about textures. There are two main things textures might refer to:</p><p>The first group I&rsquo;ll call &lsquo;Resource&rsquo; textures - these are things like <code>Texture2D</code>, <code>ImageTexture</code>, <code>NoiseTexture2D</code>, etc&mldr; You would interact with these often and put them onto things like Materials, or save them to disk. These are high level.</p><p>The second group I&rsquo;ll call &lsquo;RenderingDevice&rsquo; textures - these are lower level, essentially what &lsquo;Resource&rsquo; textures link to under the hood. These are closer to the graphics driver.</p><p>Also if you weren&rsquo;t aware, a lot of things in Godot internally are reference by a <code>RID</code> or Resource ID. Think of this like a pointer.</p><h4 id=breaking-it-down>Breaking it down</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript data-lang=gdscript><span style=display:flex><span><span style=color:#a6e22e>RenderingServer</span><span style=color:#f92672>.</span><span style=color:#a6e22e>texture_get_rd_texture</span>(<span style=color:#a6e22e>$Subviewport</span><span style=color:#f92672>.</span><span style=color:#a6e22e>get_texture</span>()<span style=color:#f92672>.</span><span style=color:#a6e22e>get_rid</span>(), <span style=color:#66d9ef>false</span>)
</span></span></code></pre></div><p>Remember the types of textures? They come into play here:</p><ol><li><code>Subviewport.get_texture()</code> - This returns a <code>ViewportTexture</code>, a subclass of <code>Texture2D</code>. This is the &lsquo;resource&rsquo; texture I mentioned about before.</li><li>We get the viewport texture&rsquo;s RID, basically the internal resource ID of the texture.</li><li><code>RenderingServer.texture_get_rd_texture</code> Looks up this &lsquo;resource&rsquo; texture ID, and gives us the RID of a &lsquo;Rendering device&rsquo; (RD) texture. This is the low level RID of the texture thats actually on the GPU.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript data-lang=gdscript><span style=display:flex><span><span style=color:#66d9ef>var</span> in_tex_format <span style=color:#f92672>=</span> rd<span style=color:#f92672>.</span><span style=color:#a6e22e>texture_get_format</span>(in_tex)
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> out_tex_format <span style=color:#f92672>=</span> in_tex_format
</span></span><span style=display:flex><span>out_tex_format<span style=color:#f92672>.</span>usage_bits <span style=color:#f92672>=</span> out_tex_format<span style=color:#f92672>.</span>usage_bits <span style=color:#f92672>|</span> <span style=color:#a6e22e>RenderingDevice</span><span style=color:#f92672>.</span>TEXTURE_USAGE_CAN_COPY_TO_BIT
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> out_texture <span style=color:#f92672>=</span> rd<span style=color:#f92672>.</span><span style=color:#a6e22e>texture_create</span>(out_tex_format, <span style=color:#a6e22e>RDTextureView</span><span style=color:#f92672>.</span><span style=color:#a6e22e>new</span>(), [])
</span></span></code></pre></div><p>The format tells the GPU how the data is structured (i.e. how many bytes to expect and where) and how it can be used.
We need to add <code>TEXTURE_USAGE_CAN_COPY_TO_BIT</code> to the output texture, since we will be copying the data to it. These are <a href=https://en.wikipedia.org/wiki/Bitwise_operation>bitwise operations</a>, hence the <code>|</code>.</p><p>Then we just make a new texture directly on the GPU (we bypass Godots &lsquo;resource&rsquo; texture layer here) via the Rendering device.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript data-lang=gdscript><span style=display:flex><span>rd<span style=color:#f92672>.</span><span style=color:#a6e22e>texture_copy</span>(in_texture, out_texture, <span style=color:#a6e22e>Vector3</span><span style=color:#f92672>.</span>ZERO, <span style=color:#a6e22e>Vector3</span><span style=color:#f92672>.</span>ZERO, <span style=color:#a6e22e>Vector3</span>(image_size<span style=color:#f92672>.</span>x, image_size<span style=color:#f92672>.</span>y, <span style=color:#ae81ff>0</span>), <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)
</span></span></code></pre></div><p>Now for the good stuff! This is a neat little function that instructs the GPU to copy from the input texture (the viewports texture) to our new output texture. This means the actual texture data doesn&rsquo;t ever really touch the CPU.</p><p>Note the <code>Vector3</code> might seem a bit odd, but they are there for use with 3D textures (we don&rsquo;t care about the 3rd value, so its just zero here)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript data-lang=gdscript><span style=display:flex><span><span style=color:#66d9ef>var</span> sprite_tex <span style=color:#f92672>=</span> Texture2DRD<span style=color:#f92672>.</span><span style=color:#a6e22e>new</span>()
</span></span><span style=display:flex><span>sprite_tex<span style=color:#f92672>.</span>texture_rd_rid <span style=color:#f92672>=</span> out_texture
</span></span></code></pre></div><p>Now we have the texture copied, but it&rsquo;s only stored at the low level. We need a way to use this with everyday Godot things like Sprites. Luckily, in 4.2 <code>Texture2DRD</code> was added. This allows us to map a texture created on the RenderingDevice and link it with a normal texture that we can use in Materials and the like.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript data-lang=gdscript><span style=display:flex><span><span style=color:#66d9ef>await</span> <span style=color:#a6e22e>get_tree</span>()<span style=color:#f92672>.</span>process_frame
</span></span><span style=display:flex><span>rd<span style=color:#f92672>.</span><span style=color:#a6e22e>free_rid</span>(out_texture)
</span></span></code></pre></div><p>After using the texture and we are done with it, we need to clean it up manually otherwise Godot will keep the texture in the GPU and the memory will slowly fill until your GPU dies. Waiting a frame stops currently in use objects (who might be visible currently but will disappear in the next frame) not &lsquo;flicker&rsquo; because they lost their texture, since <code>free_rid</code> happens immediately.</p><h3 id=the-results>The results</h3><table><thead><tr><th>Viewport size (square)</th><th>Processing time via get_image</th><th>Processing time via texture_copy</th></tr></thead><tbody><tr><td>64</td><td>0.4ms</td><td>0.006ms</td></tr><tr><td>1024</td><td>33 ms</td><td>0.008ms</td></tr><tr><td>2048</td><td>89 ms</td><td>0.011ms</td></tr></tbody></table><p>The results are quite impressive. Clearly because the GPU is able to parallelise the copy, it scales a lot slower than the CPU bound version (which would theoretically scale linearly by the number of pixels).</p></article></div></main></body></html>